---
title: "Manuscript results: models comparasion using the FluSight baseline"
author: "Victor Felix"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document: default
---

This document has the results that we present in our manuscript draft. We replace the AUTO_AR model for the FluSight baseline.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading libraries.

```{r}
library("tidyr")
library("MMWRweek")
library("data.table")
library("caret")
library("purrr")
library("dplyr")
library("tseries")
library("gtools")
library("forecast")
library("scoringutils")
library("covidHubUtils")
library("parallel")
library("future")#https://cran.r-project.org/web/packages/future/vignettes/future-4-issues.html
library("listenv")
library("epitools")
library("ggplot2")
library("sf")
library("forcats")
library("ggplot2")
library("sf")
library("scales") 
library("ggplot2")
library("broom")
library("fields")
library("ggpubr")
library("patchwork")
library("ggpattern")
library("cowplot")
library("lme4")
library("ez")
library("ggpubr")
```

Loading the results of each model and the shapefiles of the maps.

```{r}

load("models_without_logback/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization_nolog.Rdata")
load("models_without_logback/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization_nolog.Rdata")
load("models_without_logback/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization_nolog.Rdata")
load("models_without_logback/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization_nolog.Rdata")
load("models_without_logback/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization_nolog.Rdata")

states <- read_sf("models_without_logback/shapefiles/cb_2018_us_state_500k.shp")

states <- states %>%
  rename(STATE = NAME)

```
------------
1 Week ahead
------------
```{r}

# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK1$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK1$WIS
)

head(df_W1_NoLg)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Weeks Ahead
df_W2_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK2$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK2$WIS
  
)

head(df_W2_NoLg)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek


# Dataframe that will be analysed for 3 Weeks Ahead
df_W3_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK3$WIS,
    
  ES27_AR=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK3$WIS,
    
  ES64_AR=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK3$WIS
)

head(df_W3_NoLg)
```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 4 Weeks Ahead
df_W4_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK4$WIS, 
  
  ES27_AR=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4_NoLg)
```

Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1_NoLg <- df_W1_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1_NoLg)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2_NoLg <- df_W2_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3_NoLg <- df_W3_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4_NoLg <- df_W4_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4_NoLg)

```

Here we load the flusight baseline wis and replace with the AUTO_AR model for comparasion. We keep the name as AUTO_AR so we don't need to change the whole pipeline.

```{r}
flusight_baseline<-read.csv("flusight_wis_final.csv") # it was 3

flusight_wis<-data.frame(STATE=flusight_baseline$wis_by_STATE.STATE,
horizon=flusight_baseline$wis_by_STATE.horizon,
Julian_date=as.Date(flusight_baseline$wis_by_STATE.target_end_date),
AUTO_AR=flusight_baseline$wis_by_STATE.wis)


filtered_df_W1_NoLg <- filtered_df_W1_NoLg %>%
  select(-AUTO_AR) %>%  # remove existing AUTO_AR
  left_join(flusight_wis %>% filter(horizon == 0), 
            by = c("STATE", "Julian_date"))

filtered_df_W2_NoLg <- filtered_df_W2_NoLg %>%
  select(-AUTO_AR) %>%  # remove existing AUTO_AR
  left_join(flusight_wis %>% filter(horizon == 1), 
            by = c("STATE", "Julian_date"))

filtered_df_W3_NoLg <- filtered_df_W3_NoLg %>%
  select(-AUTO_AR) %>%  # remove existing AUTO_AR
  left_join(flusight_wis %>% filter(horizon == 2), 
            by = c( "STATE", "Julian_date"))

filtered_df_W4_NoLg <- filtered_df_W4_NoLg %>%
  select(-AUTO_AR) %>%  # remove existing AUTO_AR
  left_join(flusight_wis %>% filter(horizon == 3), 
            by = c( "STATE", "Julian_date"))
```


Computing mean weighted interval score for all target week for each model.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),
      AUTO_ADJ = mean(AUTO_ADJ, na.rm = TRUE),
      AUTO_EPI = mean(AUTO_EPI, na.rm = TRUE),
      AUTO_TMP = mean(AUTO_TEMP, na.rm = TRUE),
      AUTO_AVG = mean(AUTO_AVG, na.rm = TRUE),
      
      ES27_AR = mean(ES27_AR, na.rm = TRUE),
      ES27_ADJ = mean(ES27_ADJ, na.rm = TRUE),
      ES27_EPI = mean(ES27_EPI, na.rm = TRUE),
      ES27_TMP = mean(ES27_TEMP, na.rm = TRUE),
      ES27_AVG = mean(ES27_AVG, na.rm = TRUE),
      
      ES64_AR = mean(ES64_AR, na.rm = TRUE),
      ES64_ADJ = mean(ES64_ADJ, na.rm = TRUE),
      ES64_EPI = mean(ES64_EPI, na.rm = TRUE),
      ES64_TMP = mean(ES64_TEMP, na.rm = TRUE),
      ES64_AVG = mean(ES64_AVG, na.rm = TRUE)
    )
}

# Now you can use the function with any dataframe
W1_NoLg <- calculate_mean_wis(filtered_df_W1_NoLg)
W2_NoLg <- calculate_mean_wis(filtered_df_W2_NoLg)
W3_NoLg <- calculate_mean_wis(filtered_df_W3_NoLg)
W4_NoLg <- calculate_mean_wis(filtered_df_W4_NoLg)

# Display the resulting dataframe
head(W1_NoLg)
head(W2_NoLg)
head(W3_NoLg)
head(W4_NoLg)

```

Loading model with log-back transformations.

```{r}
load("models_with_logback/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization.Rdata")
load("models_with_logback/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization.Rdata")
load("models_with_logback/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization.Rdata")
load("models_with_logback/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization.Rdata")
load("models_with_logback/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization.Rdata")
```

------------
1 Week ahead
------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1 <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK1$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK1$WIS  
)

head(df_W1)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W2 <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK2$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK2$WIS  
)

head(df_W2)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W3 <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK3$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK3$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK3$WIS  
)

head(df_W3)

```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W4 <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK4$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4)
```

Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1 <- df_W1 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2 <- df_W2 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3 <- df_W3 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4 <- df_W4 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4)
```

Calculate mean weighted interval score for influenza seasons on each model and each state.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR_LB = mean(AUTO_AR_LB, na.rm = TRUE),
      AUTO_ADJ_LB = mean(AUTO_ADJ_LB, na.rm = TRUE),
      AUTO_EPI_LB = mean(AUTO_EPI_LB, na.rm = TRUE),
      AUTO_TMP_LB = mean(AUTO_TEMP_LB, na.rm = TRUE),
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE),
      
      ES27_AR_LB = mean(ES27_AR_LB, na.rm = TRUE),
      ES27_ADJ_LB = mean(ES27_ADJ_LB, na.rm = TRUE),
      ES27_EPI_LB = mean(ES27_EPI_LB, na.rm = TRUE),
      ES27_TMP_LB = mean(ES27_TEMP_LB, na.rm = TRUE),
      ES27_AVG_LB = mean(ES27_AVG_LB, na.rm = TRUE),
      
      ES64_AR_LB = mean(ES64_AR_LB, na.rm = TRUE),
      ES64_ADJ_LB = mean(ES64_ADJ_LB, na.rm = TRUE),
      ES64_EPI_LB = mean(ES64_EPI_LB, na.rm = TRUE),
      ES64_TMP_LB = mean(ES64_TEMP_LB, na.rm = TRUE),
      ES64_AVG_LB = mean(ES64_AVG_LB, na.rm = TRUE),
    )
}

# Now we can use the function with any dataframe
W1_Lg <- calculate_mean_wis(filtered_df_W1)
W2_Lg <- calculate_mean_wis(filtered_df_W2)
W3_Lg <- calculate_mean_wis(filtered_df_W3)
W4_Lg <- calculate_mean_wis(filtered_df_W4)

# Display the resulting dataframe
head(W1_Lg)
head(W2_Lg)
head(W3_Lg)
head(W4_Lg)
```

COMBINING THE RESULTS WITH LOG-BACK AND NO LOG-BACK TRASNFORMATION

```{r}
W1<-merge(W1_Lg,W1_NoLg, by = "STATE")
W2<-merge(W2_Lg,W2_NoLg, by = "STATE")
W3<-merge(W3_Lg,W3_NoLg, by = "STATE")
W4<-merge(W4_Lg,W4_NoLg, by = "STATE")
```



Here I include a column with the best model based on the lowest mean(WIS) of each state.

```{r}
# BEST RESULT

cols <- colnames(W1)[-1] # get states names
W1$Best_Result <- character(nrow(W1)) # create an empty column for the best models

# Give me the model with lower WIS value 
for (i in 1:nrow(W1)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W1$Best_Result[i] <- cols[which.min(W1[i, cols])]
}

# REORDER BY FREQUENCY
W1$Best_Result <- fct_infreq(W1$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W1$Model_Type <- ifelse(grepl("_LB$", W1$Best_Result), "With log-back transformation", "Without log-back transformation")

# Print the first rows
head(W1)

################################################

# Extract the columns of interest 
cols <- colnames(W2)[-1]  # get states names
W2$Best_Result <- character(nrow(W2)) # create an empty column for the best models
# Give me the model with lower WIS value 
for (i in 1:nrow(W2)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W2$Best_Result[i] <- cols[which.min(W2[i, cols])]
}

# REORDER BY FREQUENCY
W2$Best_Result <- fct_infreq(W2$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W2$Model_Type <- ifelse(grepl("_LB$", W2$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W2)

######################################
# BEST RESULT
# Extract the columns of interest 
cols <- colnames(W3)[-1] # get states names
W3$Best_Result <- character(nrow(W3))# create an empty column for the best models
# Give me the model with lower WIS value
for (i in 1:nrow(W3)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W3$Best_Result[i] <- cols[which.min(W3[i, cols])]
}

# REORDER BY FREQUENCY
W3$Best_Result <- fct_infreq(W3$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W3$Model_Type <- ifelse(grepl("_LB$", W3$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W3)

###################################
# BEST RESULT
# Extract the columns of interest 
cols <- colnames(W4)[-1] # get states names
W4$Best_Result <- character(nrow(W4)) # create an empty column for the best models

# Give me the model with lower WIS value
for (i in 1:nrow(W4)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W4$Best_Result[i] <- cols[which.min(W4[i, cols])]
}
W4$Best_Result <- fct_infreq(W4$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W4$Model_Type <- ifelse(grepl("_LB$", W4$Best_Result),  "With log-back transformation","Without log-back transformation")
# Print merged results
head(W4)

```

 
Now we use a Wilcoxon test with Holm p-value adjustment for repeated comparisons to evaluate the differences in model performances. 

1 WEEK AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W1), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results1 <- map_df(model_types, function(model) {
  test <- wilcox.test(W1[[model]], W1$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results1$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk1 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=1)
p_values_wk1 <-drop_na(p_values_wk1)
p_values_wk1

```

2 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W2), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results2 <- map_df(model_types, function(model) {
  test <- wilcox.test(W2[[model]], W2$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results2$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk2 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=2)
p_values_wk2 <-drop_na(p_values_wk2)
p_values_wk2
```

3 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W3), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results3 <- map_df(model_types, function(model) {
  test <- wilcox.test(W3[[model]], W3$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results3$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk3 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=3)
p_values_wk3 <-drop_na(p_values_wk3)
p_values_wk3
```

4 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W4), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results4 <- map_df(model_types, function(model) {
  test <- wilcox.test(W4[[model]], W4$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# Perform Wilcoxon test for each model type against AUTO_AAR
p_values<-wilcox_results4$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk4 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=4)
p_values_wk4 <-drop_na(p_values_wk4)
p_values_wk4

```

Let's calculate the mean(WIS) improvement relative to the AUTO ARIMA model. We will compare each model with the AUTO ARIMA model for the same states. Later we sum the results of these comparisons. Negative results indicate that there was a general improvement in the mean(WIS) for a given model type among all states. 

```{r}
calculate_percentage_of_improvement <- function(data) {
  return(data.frame(
    AUTO_AR = (((data$AUTO_AR / data$AUTO_AR)-1) * 100),
    ES27_AR = (((data$ES27_AR/data$AUTO_AR)-1) * 100),
    ES64_AR = (((data$ES64_AR/data$AUTO_AR )-1) * 100),
   
    AUTO_ADJ = (((data$AUTO_ADJ/data$AUTO_AR)-1) * 100),
    ES27_ADJ = (((data$ES27_ADJ/data$AUTO_AR)-1) * 100),
    ES64_ADJ = (((data$ES64_ADJ/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP = (((data$AUTO_TMP/data$AUTO_AR)-1) * 100),
    ES27_TMP = (((data$ES27_TMP/data$AUTO_AR)-1) * 100),
    ES64_TMP = (((data$ES64_TMP/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI = (((data$AUTO_EPI/data$AUTO_AR)-1) * 100),
    ES27_EPI = (((data$ES27_EPI/data$AUTO_AR)-1) * 100),
    ES64_EPI = (((data$ES64_EPI/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG = (((data$AUTO_AVG/data$AUTO_AR)-1) * 100),
    ES27_AVG = (((data$ES27_AVG/data$AUTO_AR)-1) * 100),
    ES64_AVG = (((data$ES64_AVG/data$AUTO_AR)-1) * 100),
    
    AUTO_AR_LB = (((data$AUTO_AR_LB/data$AUTO_AR)-1) * 100),
    ES27_AR_LB = (((data$ES27_AR_LB/data$AUTO_AR)-1) * 100),
    ES64_AR_LB = (((data$ES64_AR_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_ADJ_LB = (((data$AUTO_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES27_ADJ_LB = (((data$ES27_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES64_ADJ_LB = (((data$ES64_ADJ_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP_LB = (((data$AUTO_TMP_LB/data$AUTO_AR)-1) * 100),
    ES27_TMP_LB = (((data$ES27_TMP_LB/data$AUTO_AR)-1) * 100),
    ES64_TMP_LB = (((data$ES64_TMP_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI_LB = (((data$AUTO_EPI_LB/data$AUTO_AR)-1) * 100),
    ES27_EPI_LB = (((data$ES27_EPI_LB/data$AUTO_AR)-1) * 100),
    ES64_EPI_LB = (((data$ES64_EPI_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG_LB = (((data$AUTO_AVG_LB/data$AUTO_AR)-1) * 100),
    ES27_AVG_LB = (((data$ES27_AVG_LB/data$AUTO_AR)-1) * 100),
    ES64_AVG_LB = (((data$ES64_AVG_LB/data$AUTO_AR)-1) * 100)    
  ))
}

# Calculate percentage of improvement 
W1_percentage_of_improvement <- calculate_percentage_of_improvement(W1)
W2_percentage_of_improvement <- calculate_percentage_of_improvement(W2)
W3_percentage_of_improvement <- calculate_percentage_of_improvement(W3)
W4_percentage_of_improvement <- calculate_percentage_of_improvement(W4)

head(W1_percentage_of_improvement)
head(W2_percentage_of_improvement)
head(W3_percentage_of_improvement)
head(W4_percentage_of_improvement)
```

Now let's plot histograms of percentage of WIS improvement for each state including mean and standard deviation of percentage of improvement compared to auto_arima (baseline).

```{r}
# List of models names
models_names <-c(names(W1_percentage_of_improvement))

# Create an empty dataframe to store results
summary_impr <- data.frame(WeekAhead = character(), Model = character(), m = numeric(), sd = numeric(), stringsAsFactors = FALSE)

# List of datasets. One dataset for each target week.
datasets_list <- list("1" = W1_percentage_of_improvement, 
                 "2" = W2_percentage_of_improvement, 
                 "3" = W3_percentage_of_improvement, 
                 "4" = W4_percentage_of_improvement)

# Here I have 2 for loops. One take into account the target week and the other the model.
# Loop through target weeks
for (target_week_ in names(datasets_list)) {
  dataset <- datasets_list[[target_week_]]  # Get the dataset based on target week
  # Loop through models
  for (given_model in models_names) {
    data <- dataset[[given_model]]
    mean_val <- mean(data, na.rm = TRUE)
    sd_val <- sd(data, na.rm = TRUE)

    # Append results to dataframe
    summary_impr <- rbind(summary_impr, data.frame(WeekAhead = target_week_, Model = given_model, m = mean_val, sd = sd_val))

    # Generate histogram
    p <- ggplot(dataset, aes(x = .data[[given_model]])) +
      geom_histogram(color = "black", fill = "lightblue", bins = 30, alpha = 0.7) +
      geom_vline(aes(xintercept = mean_val), color = "red", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val - sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val + sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      labs(title = paste("Histogram of", given_model, "target week", target_week_),
           x = given_model, 
           y = "Frequency") +
      theme_minimal()

    print(p)  # Display the plot
  }
}

summary_impr$WeekAhead<-as.numeric(summary_impr$WeekAhead)

#summary_impr
```

Let create a combined dataset with mean differences, standard deviations and Wilcoxon Holm adjusted p-values

```{r}
# 

all_p_values<-rbind(p_values_wk1,p_values_wk2,p_values_wk3,p_values_wk4)

p_values_and_impr <- merge(summary_impr, all_p_values, by = c("WeekAhead", "Model"))

# Create a new column "Model_Type" based on model with and without log-back transformation
p_values_and_impr$Model_Type <- ifelse(grepl("_LB$", p_values_and_impr$Model), "LB", "no_LB")

# View the updated dataframe
head(p_values_and_impr)
p_values_and_impr
```
Here we are plotting the mean differences and standard deviation

```{r}

# Get model order based based on lower values on WeekAhead == 1  
model_order <- p_values_and_impr %>%
  filter(WeekAhead == 1) %>%
  arrange(desc(m)) %>%
  pull(Model) 

# Prepare data with significance level, ordering, and model name
p_df <- p_values_and_impr %>%
  mutate(Significance = ifelse(p_values < 0.05 , "Significant", "Not Significant"),
         Model_Type = ifelse(grepl("_LB$", Model), "With log-back transformation", "Without log-back transformation"),
         Model = factor(Model, levels = model_order))  

# Heatmap plot  
plot_m_heatmap <- ggplot(p_df, aes(x = factor(WeekAhead), y = Model, fill = m)) +
  geom_tile(aes(fill = ifelse(Significance == "Significant", m, NA)), color = "black") +  # Fill only significant ones
  geom_tile(data = p_df %>% filter(Significance == "Not Significant"), 
            aes(x = factor(WeekAhead), y = Model), fill = "gray80", color = "black") +  # Gray for non-significant
  geom_text(aes(label = paste0("m:", round(m, 1),", sd:", round(sd, 1))), 
            color = "black", size = 4) +  # Add text labels
  scale_fill_gradient2(
  low = "cyan", 
  mid = "white", 
  high = "red", 
  midpoint = 0,     # <-- Sets 0 as the midpoint
  na.value = "gray80", 
  name = "Mean difference", 
  limits = c(-35, 35)       
)+
  labs(title = "Mean differences between models' WIS and the FluSight baseline across 48 states",
       subtitle = "Gray boxes indicate models that are not significantly different from the baseline (p>0.05)",
         caption = "m = mean difference, sd = standard deviation",
       x = "Target Week",
       y = "") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
  plot.caption = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),) +
  facet_wrap(~ Model_Type, scales = "free_y") 



# Print plot
print(plot_m_heatmap)
ggsave("Fig12.jpg", plot_m_heatmap, width = 14, height = 7 )

```

Now let's organize the data to plot some maps with the best models.

```{r}
# MAP 1 week ahead
W1_map <- data.frame(
  STATE = W1$STATE,
  percentage_improvement = W1_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG_LB=W1$AUTO_AVG_LB
)

# Include geometry
W1_map <- states %>%
  left_join(W1_map, by = c("STATE")) %>%
  drop_na()

# MAP 2 weeks a ahead
W2_map <- data.frame(
  STATE = W2$STATE,
  percentage_improvement = W2_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG_LB=W2$AUTO_AVG_LB
)

# Include geometry
W2_map <- states %>%
  left_join(W2_map, by = c("STATE"))%>%
  drop_na()

# MAP 3 weeks a ahead
W3_map <- data.frame(
  STATE = W3$STATE,
  percentage_improvement = W3_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG_LB=W3$AUTO_AVG_LB
)

# Include geometry
W3_map <- states %>%
  left_join(W3_map, by = c("STATE"))%>%
  drop_na() 

# MAP 4 weeks ahead
W4_map <- data.frame(
  STATE = W4$STATE,
  percentage_improvement = W4_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG_LB=W4$AUTO_AVG_LB
)

# Include geometry
W4_map <- states %>%
  left_join(W4_map, by = c("STATE"))%>%
  drop_na()
```



Let's plot some maps with the with the mean difference (%) between the AUTO_AVG_LB and the AUTO ARIMA models for the same state.

1 week ahead percentage of improvement

```{r}

ES_1WEEK <- ggplot(W1_map) +
  geom_sf(aes(fill = percentage_improvement)) +  
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("1 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W1_map, aes(label = round(percentage_improvement,0)),
               size = 2.6,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  
  labs(
    fill = "Mean difference", 
       x = "",
       y = ""
  )  

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_1WEEK<-ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
```

2 weeks ahead

```{r}

ES_2WEEK <- ggplot(W2_map) +
  geom_sf(aes(fill = percentage_improvement)) + 
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("2 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W2_map, aes(label = round(percentage_improvement,0)), 
               size = 2.6,
               color = "black",
               check_overlap = TRUE,fontface = "bold") + 
  labs(
    fill = "Mean difference",  
       x = "",
       y = ""
  )  # Adding a subtitle


x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
```

3 weeks ahead

```{r}

ES_3WEEK <- ggplot(W3_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("3 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W3_map, aes(label = round(percentage_improvement,0)),  
               size = 2.6,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill =  "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

```

4 weeks ahead

```{r}
ES_4WEEK <- ggplot(W4_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("4 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W4_map, aes(label = round(percentage_improvement,0)), 
               size = 2.6,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

```

Combining plot on a 2x2 grid.

```{r}
# Ensure each plot has coord_sf applied
ES_1WEEK <- ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_2WEEK <- ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_3WEEK <- ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_4WEEK <- ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

# Combine in a 2x2 grid
combined_plot <- (ES_1WEEK | ES_2WEEK) /
                 (ES_3WEEK | ES_4WEEK) + 
  plot_annotation(
    title = "",
    subtitle = "",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )

# Print
print(combined_plot) 

# Save to file
ggsave("Fig13.jpg", combined_plot, width =12, height =7)
```

Loading datasets for regression models analysis

```{r}
pop_data <- read.csv("models_with_logback/regression_features/population_data.csv") # resident population and population density
sovi_data <- read.csv("models_with_logback/regression_features/sovi_2010.2014.csv") # SOVI index
bric_data<-read.csv("models_with_logback/regression_features/bric2015.csv") # BRIC index
humidity_data<-read.csv("models_with_logback/regression_features/humidity_climatology_1990_2020.csv") # ERA5 Specific Humidity
temperature_data<-read.csv("models_with_logback/regression_features/temperature_climatology_1990_2020.csv") # ERA5 Specific Temperature

```
REGRESSION MODELS

Now we will run the regression models for evaluating if the best model percentage of improvement in each state is related to given independent variables.

```{r}

# List of data frames
WIS_dataframes <- list(W1 = W1_map, W2 = W2_map, W3 = W3_map, W4=W4_map)
regression_models<-data.frame()

```

Percentage of improvement regression analysis

AUTO_AVG_LB WIS x RESIDENT POPULATION 2020

```{r}

for(i in c(1,2,3,4)){

  # Combining data for the same states
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fitting the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Resident_population_2020))
  # View the model summary
  model_summary <- summary(model)
  # Getting the R and p values for the plot
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # Saving the results in a dataframe
  regression_models2 <- data.frame(
    independent_variable = "Resident Population (2020)", 
    Week_Ahead = i, 
    r_squared = r_squared, 
    p_value = p_value
  )
  # Append to the main results dataframe
  regression_models <- rbind(regression_models, regression_models2)
}

regression_models
```

AUTO_AVG_LB WIS x POPULATION DENSITY

```{r}

for(i in c(1,2,3,4)){

  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Population_density_2020))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Population Density (2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # Append to the main results dataframe
  regression_models<-rbind(regression_models,regression_models2)
}

```

Here we will weight the Social Vulnerability Index (SoVI) and Baseline Resilience Indicators for Communities (BRIC) county indexes which for each states based on the population size in each county.

```{r}
#############################################################
# SOVI BY STATE
# weighted by population size in each county
sovi_by_state <- sovi_data %>%
  filter(!is.nan(sovi)) %>%  # Exclude rows where 'sovi' is NaN
  group_by(state.name) %>%
  summarize(weighted_mean = weighted.mean(sovi, w = population.2020, na.rm = TRUE))

colnames(sovi_by_state)[1] <- "STATE"

#############################################################
# BRIC BY STATE
# weighted by population size in each county

bric_by_state <- bric_data %>%
  group_by(state.name) %>%
  summarize(across(16:22, ~ weighted.mean(.x, w = population.2020, na.rm = TRUE), .names = "weighted_mean_{col}"))
colnames(bric_by_state)[1] <- "STATE"

```

AUTO_AVG_LB WIS x SOVI

```{r}

for(i in c(1,2,3,4)){

  WIS_sovi<-NULL
  WIS_sovi <- inner_join(WIS_dataframes[[i]], sovi_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_sovi$percentage_improvement) ~ (WIS_sovi$weighted_mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Social Vulnerability Index (SoVI)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC SOCIAL

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model  
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.social))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Social (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC ECONOMIC

```{r}
for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.economic))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Economic (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC Infrastructure

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.infrastructure))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Infrastructure (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

Plotting best regression model

```{r}

# Prepare a list of plots
bric_plots <- list()

for (i in 1:4) {
  # Join the WIS and BRIC data
  WIS_bric <- inner_join(
    WIS_dataframes[[i]],
    bric_by_state,
    by = "STATE"
  )
  
  # Fit the linear model
  model <- lm(
    percentage_improvement ~ weighted_mean_z_bric.infrastructure,
    data = WIS_bric
  )
  ms <- summary(model)
  
  # Extract R-squared and p-value
  r2 <- round(ms$r.squared, 3)
  p  <- signif(ms$coefficients[2, 4], 3)
  
  # Build the ggplot
  p <- ggplot(WIS_bric,
              aes(x = weighted_mean_z_bric.infrastructure,
                  y = percentage_improvement)) +
    geom_point(color = "steelblue", size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "darkred") +
    labs(
      title    = paste("Regression","Target Week", i),
      subtitle = paste0("R = ", r2, "   p = ", p),
      x        = "BRIC infrastructure (2015)",
      y        = "Difference"
    ) +
    theme_minimal()
  
  # Store it
  bric_plots[[i]] <- p
}

# Combine the plots vertically
combined_regressions <- wrap_plots(bric_plots, ncol = 1)

# Display 
combined_regressions

```

AUTO_AVG_LB WIS x BRIC institutional

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.institutional))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Institutional (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC community

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[1]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.community))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Community (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC environment

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.environment))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Environment (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG_LB WIS x BRIC total

```{r}

for(i in 1:4){
  # BRIC INDEX
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.total))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC total (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}
```

TEMPERATUE - ERA5

Now we will look at regression models that uses mean temperature and specific humidity.

-------------------

AUTO_AVG_LB WIS x Temperature ERA5 Data

```{r}

for(i in 1:4){
  # TEMPERATURE DATA from ERA5
  WIS_temp <- inner_join(WIS_dataframes[[i]], temperature_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_temp$percentage_improvement) ~ (WIS_temp$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Temperature (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}
```

AUTO_AVG_LB WIS x Specific Humidity ERA5 Data

```{r}

# regression results 
print(regression_models)

for(i in 1:4){
  # HUMIDITY DATA from ERA5
  WIS_humidity <- inner_join(WIS_dataframes[[i]], humidity_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_humidity$percentage_improvement) ~ (WIS_humidity$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Specific Humidty (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

# Plot the table
regression_models
```
SUMMARY OF RESULTS 

```{r}
# Define a significance threshold (p < 0.05)
regression_models <- regression_models %>%
  mutate(significance = ifelse(p_value < 0.05, "Significant", "Not Significant"))

# Plot
reg2<-ggplot(regression_models, aes(x = Week_Ahead, y = independent_variable, fill = significance)) +  
  geom_tile(color = "black") +  # Add black borders to squares
  geom_text(aes(label = round(r_squared, 3)), color = "black", size = 6) +  # Text inside boxes
  scale_fill_manual(values = c("Significant" = "cyan", "Not Significant" = "gray")) +  
  labs(title = "Regression models R",
       subtitle = "Mean WIS differences as dependent variable",
       x = "Target Week",
       y = "Independent Variables",
       fill = "Significance (p < 0.05)") +    
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

reg2

reg2_scatter <- reg2 | combined_regressions 
reg2_scatter
ggsave(reg2_scatter, height = 6, width = 12, filename="Fig14.jpg")  
#ggsave(reg2, filename="Fig9.jpg",height = 6, width = 8)
```


Here we will be computing and plotting mean WIS improvement by epidemiological weeks comparing the best model and the baseline model.

```{r}
# Create a list of data frames for the four weeks
weeks <- 1:4
results_by_epiweek_list <- list()

for (week in weeks) {
  # Merge the data frames for the current week
  combined_dataframes_ <- merge(get(paste0("filtered_df_W", week, "_NoLg")),
                  get(paste0("filtered_df_W", week)))
  
  # Sum values by Julian date across all states
  mean_improvement_ <- combined_dataframes_ %>%
    group_by(Julian_date) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),  # Mean across all states
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE) # Mean across all states
    ) %>%
    # Calculate the difference ratio in percentage
    mutate(Difference =  ((AUTO_AVG_LB / AUTO_AR)-1)*100,
           Week = paste0("Week ", week))
  
  # Store the mean improvement by julian date
  results_by_epiweek_list[[week]] <- mean_improvement_
}

# Combine all weeks into a single data frame
results_by_epiweek_all <- bind_rows(results_by_epiweek_list)

# Plot the results
model_improv<-ggplot(results_by_epiweek_all, aes(x = Julian_date, y = (Difference), color = Week)) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 0.8) +
  theme_minimal() +
  labs(
    title = "A) Weekly mean WIS differences across all states",
    subtitle = "AUTO_AVG_LB compared to FluSight baseline",
    x = "",
    y = "Mean difference"
  ) +
  scale_y_continuous(
    limits = c(-85, 155),
    breaks = seq(-85, 155, by = 20)
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
scale_color_manual(
  values = c(
    "Week 1" = "#4575B4",  # Blue
    "Week 2" = "#91BFDB",  # Light blue
    "Week 3" = "#E89C9C",  # Light red
    "Week 4" = "#D73027"   # Red
  )
) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

model_improv

```
Total hospitalizations

```{r}

# get total hospitalizations for the 48 states
total_hospitalizations_by_week <- AUTO_ADJACENT_WEEK1 %>%
  filter(epiweek >= 40 | epiweek <= 20) %>%  
  group_by(target_end_date) %>%
  summarise(mean_cases = sum(cases, na.rm = TRUE))

# plotting results
hospital_plot <-ggplot(total_hospitalizations_by_week, aes(x = target_end_date, y = mean_cases)) +
  geom_bar(stat = "identity",fill = "steelblue") +
  labs(title = "B) Total influenza hospitalizations in the 48 states",
       x = "",
       y = "Influenza hospitalizations") +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
  theme_minimal()+
  theme(plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1))

hospital_plot

```

Combining model improvement and total hospitalizations

```{r}
# Combining results in a single plot
combined_plot <-  model_improv /hospital_plot 
combined_plot

# Save the combined plot
ggsave("Fig15.jpg", combined_plot, width = 7, height = 7, dpi = 600)

```